# 通知模块设计文档

## 1. 模块概述

通知模块负责系统的实时通知功能，通过WebSocket将任务变更、留言、预警等信息推送给客户端。

## 2. 核心功能

- WebSocket连接管理
- 实时消息推送
- 通知记录存储(可选)
- 离线消息处理
- 心跳保持连接

## 3. 技术架构

### 3.1 技术选型
- **Flask-SocketIO**: WebSocket服务端
- **Socket.IO Client**: 浏览器端/客户端
- **Redis**(可选): 多实例部署时的消息代理

### 3.2 连接模型

```
客户端 <--WebSocket--> Flask-SocketIO <--> NotificationService
                            ↓
                        Redis(可选)
```

## 4. WebSocket服务端

### 4.1 SocketIO初始化

```python
from flask import Flask
from flask_socketio import SocketIO, emit, join_room, leave_room
from flask_jwt_extended import decode_token

app = Flask(__name__)
socketio = SocketIO(app, cors_allowed_origins="*")

# 存储用户连接
user_connections = {}  # {user_id: [sid1, sid2, ...]}

@socketio.on('connect')
def handle_connect(auth):
    """
    客户端连接
    :param auth: {'token': 'JWT_TOKEN'} 或 {'um_code': 'UM001'}
    """
    try:
        # 方式1: JWT认证
        if 'token' in auth:
            token = auth['token']
            payload = decode_token(token)
            user_id = payload['sub']
        # 方式2: UM编号认证(用于EXE客户端)
        elif 'um_code' in auth:
            from app.services.user_service import UserService
            user = UserService.get_user_by_um_code(auth['um_code'])
            if not user:
                return False
            user_id = user.id
        else:
            return False

        # 加入用户专属房间
        room = f'user_{user_id}'
        join_room(room)

        # 记录连接
        from flask import request
        sid = request.sid
        if user_id not in user_connections:
            user_connections[user_id] = []
        user_connections[user_id].append(sid)

        print(f'User {user_id} connected, sid: {sid}')

        # 发送欢迎消息
        emit('connected', {'message': '连接成功', 'user_id': user_id})

        return True

    except Exception as e:
        print(f'Connection failed: {str(e)}')
        return False

@socketio.on('disconnect')
def handle_disconnect():
    """客户端断开连接"""
    from flask import request
    sid = request.sid

    # 移除连接记录
    for user_id, sids in user_connections.items():
        if sid in sids:
            sids.remove(sid)
            print(f'User {user_id} disconnected, sid: {sid}')
            break

@socketio.on('ping')
def handle_ping():
    """心跳"""
    emit('pong', {'timestamp': datetime.now().isoformat()})
```

### 4.2 NotificationService类

```python
from flask_socketio import emit

class NotificationService:
    """通知业务逻辑服务"""

    # 通知类型常量
    TYPE_NEW_TASK = '新任务'
    TYPE_TASK_TRANSFER = '任务流转'
    TYPE_TASK_COMMENT = '任务留言'
    TYPE_TASK_WARNING = '任务预警'
    TYPE_TASK_COMPLETE = '任务完成'

    @staticmethod
    def send_notification(user_id, notification_type, title, content, task_id=None, extra_data=None):
        """
        发送通知给指定用户
        :param user_id: 用户ID
        :param notification_type: 通知类型
        :param title: 通知标题
        :param content: 通知内容
        :param task_id: 关联任务ID
        :param extra_data: 额外数据
        """
        from app import socketio

        notification = {
            'type': notification_type,
            'title': title,
            'content': content,
            'task_id': task_id,
            'timestamp': datetime.now().isoformat(),
            'extra_data': extra_data or {}
        }

        # 发送到用户专属房间
        room = f'user_{user_id}'
        socketio.emit('notification', notification, room=room)

        # 可选: 保存通知记录到数据库
        NotificationService._save_notification(user_id, notification_type, title, content, task_id)

    @staticmethod
    def _save_notification(user_id, notification_type, title, content, task_id):
        """保存通知记录(可选)"""
        from app.models.notification import Notification
        from app.utils.database import db_session

        notification = Notification(
            user_id=user_id,
            task_id=task_id,
            notification_type=notification_type,
            title=title,
            content=content,
            is_read=False
        )

        db_session.add(notification)
        db_session.commit()

    @staticmethod
    def notify_new_task(task):
        """通知新任务"""
        NotificationService.send_notification(
            user_id=task.current_handler_id,
            notification_type=NotificationService.TYPE_NEW_TASK,
            title='您有新的任务',
            content=f'「{task.title}」',
            task_id=task.id
        )

    @staticmethod
    def notify_task_transfer(task, operator_name):
        """通知任务流转"""
        NotificationService.send_notification(
            user_id=task.current_handler_id,
            notification_type=NotificationService.TYPE_TASK_TRANSFER,
            title='任务已流转给您',
            content=f'{operator_name} 将任务「{task.title}」流转给您',
            task_id=task.id
        )

    @staticmethod
    def notify_task_comment(task, comment):
        """通知任务留言"""
        # 通知当前处理人
        if task.current_handler_id != comment.user_id:
            NotificationService.send_notification(
                user_id=task.current_handler_id,
                notification_type=NotificationService.TYPE_TASK_COMMENT,
                title='任务有新留言',
                content=f'{comment.user.name} 在「{task.title}」中留言: {comment.content[:50]}...',
                task_id=task.id
            )

        # 通知创建人
        if task.creator_id != comment.user_id and task.creator_id != task.current_handler_id:
            NotificationService.send_notification(
                user_id=task.creator_id,
                notification_type=NotificationService.TYPE_TASK_COMMENT,
                title='任务有新留言',
                content=f'{comment.user.name} 在「{task.title}」中留言: {comment.content[:50]}...',
                task_id=task.id
            )

    @staticmethod
    def notify_task_warning(task, warning_level):
        """通知任务预警"""
        warning_messages = {
            20: '任务即将到期(剩余20%时间)',
            10: '任务即将到期(剩余10%时间)',
            5: '任务即将到期(剩余5%时间)'
        }

        NotificationService.send_notification(
            user_id=task.current_handler_id,
            notification_type=NotificationService.TYPE_TASK_WARNING,
            title='任务预警',
            content=f'「{task.title}」{warning_messages.get(warning_level, "即将到期")}，当前进度{task.progress}%',
            task_id=task.id,
            extra_data={'warning_level': warning_level}
        )

    @staticmethod
    def broadcast_message(message, notification_type='系统消息'):
        """广播消息给所有在线用户"""
        from app import socketio

        notification = {
            'type': notification_type,
            'title': '系统消息',
            'content': message,
            'timestamp': datetime.now().isoformat()
        }

        socketio.emit('notification', notification, broadcast=True)
```

## 5. 客户端实现

### 5.1 Web前端(Vue.js + Socket.IO Client)

```javascript
import io from 'socket.io-client'
import { ElNotification } from 'element-plus'

class NotificationClient {
  constructor() {
    this.socket = null
    this.connected = false
  }

  connect(serverUrl, token) {
    this.socket = io(serverUrl, {
      auth: { token },
      transports: ['websocket'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 10
    })

    this.socket.on('connect', () => {
      console.log('WebSocket connected')
      this.connected = true
    })

    this.socket.on('disconnect', () => {
      console.log('WebSocket disconnected')
      this.connected = false
    })

    this.socket.on('connected', (data) => {
      console.log('Server confirmed:', data)
    })

    this.socket.on('notification', (notification) => {
      this.handleNotification(notification)
    })

    // 心跳
    setInterval(() => {
      if (this.connected) {
        this.socket.emit('ping')
      }
    }, 30000)
  }

  handleNotification(notification) {
    // 播放提示音
    this.playSound()

    // 显示通知
    ElNotification({
      title: notification.title,
      message: notification.content,
      type: this.getNotificationType(notification.type),
      duration: 5000,
      onClick: () => {
        // 跳转到任务详情
        if (notification.task_id) {
          window.location.href = `/tasks/${notification.task_id}`
        }
      }
    })

    // 更新未读数量
    this.updateUnreadCount()
  }

  getNotificationType(type) {
    const typeMap = {
      '新任务': 'info',
      '任务流转': 'info',
      '任务留言': 'info',
      '任务预警': 'warning',
      '任务完成': 'success'
    }
    return typeMap[type] || 'info'
  }

  playSound() {
    const audio = new Audio('/static/notification.mp3')
    audio.play().catch(e => console.log('Sound play failed:', e))
  }

  disconnect() {
    if (this.socket) {
      this.socket.disconnect()
    }
  }
}

export default new NotificationClient()
```

### 5.2 Chrome插件

```javascript
// background.js
let socket = null

// 从storage获取配置
chrome.storage.sync.get(['serverUrl', 'umCode'], (config) => {
  if (config.serverUrl && config.umCode) {
    connectWebSocket(config.serverUrl, config.umCode)
  }
})

function connectWebSocket(serverUrl, umCode) {
  socket = io(serverUrl, {
    auth: { um_code: umCode },
    transports: ['websocket']
  })

  socket.on('notification', (notification) => {
    // 显示Chrome通知
    chrome.notifications.create({
      type: 'basic',
      iconUrl: 'icon.png',
      title: notification.title,
      message: notification.content,
      priority: 2
    }, (notificationId) => {
      // 点击通知打开任务页面
      chrome.notifications.onClicked.addListener(() => {
        if (notification.task_id) {
          chrome.tabs.create({
            url: `${serverUrl}/tasks/${notification.task_id}`
          })
        }
      })
    })
  })
}
```

### 5.3 EXE客户端(C++ WebSocket++)

```cpp
#include <websocketpp/client.hpp>
#include <json/json.h>

class NotificationClient {
private:
    websocketpp::client<websocketpp::config::asio_client> client;
    websocketpp::connection_hdl connection;

public:
    void connect(const std::string& uri, const std::string& umCode) {
        client.init_asio();

        client.set_message_handler([this](websocketpp::connection_hdl hdl,
                                          websocketpp::config::asio_client::message_type::ptr msg) {
            handleMessage(msg->get_payload());
        });

        websocketpp::lib::error_code ec;
        auto con = client.get_connection(uri, ec);

        // 设置认证
        Json::Value auth;
        auth["um_code"] = umCode;
        // ... 发送认证消息

        connection = client.connect(con);
        client.run();
    }

    void handleMessage(const std::string& payload) {
        Json::Value notification;
        Json::Reader reader;
        reader.parse(payload, notification);

        // 播放提示音
        PlaySound(TEXT("notification.wav"), NULL, SND_FILENAME | SND_ASYNC);

        // 显示系统托盘通知
        showTrayNotification(
            notification["title"].asString(),
            notification["content"].asString()
        );
    }

    void showTrayNotification(const std::string& title, const std::string& content) {
        // 使用Windows API显示通知
        // ...
    }
};
```

## 6. 消息格式规范

### 6.1 通知消息格式

```json
{
    "type": "新任务",
    "title": "您有新的任务",
    "content": "「实现用户登录功能」",
    "task_id": 123,
    "timestamp": "2025-01-15T10:30:00",
    "extra_data": {}
}
```

## 7. 性能优化

### 7.1 连接管理
- 使用房间机制，避免广播
- 定期清理断开的连接
- 限制单用户连接数

### 7.2 消息队列
- 如果用户离线，可以将消息存储到Redis队列
- 用户上线时读取离线消息

### 7.3 多实例部署
```python
# 使用Redis作为消息代理
socketio = SocketIO(app, message_queue='redis://localhost:6379')
```

## 8. 测试

### 8.1 WebSocket连接测试

```python
def test_websocket_connection():
    """测试WebSocket连接"""
    client = socketio.test_client(app, auth={'token': 'valid_jwt_token'})
    assert client.is_connected()

def test_notification_receive():
    """测试接收通知"""
    client = socketio.test_client(app, auth={'token': 'valid_jwt_token'})
    received = client.get_received()
    assert len(received) > 0
```
