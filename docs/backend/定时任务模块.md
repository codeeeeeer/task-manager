# 定时任务模块设计文档

## 1. 模块概述

定时任务模块负责系统的后台定时任务，包括周期任务重置和任务预警检测。

## 2. 核心功能

- 周期任务重置
- 任务预警检测(20%、10%、5%)
- 时间进度更新
- 定时数据清理(可选)

## 3. 技术架构

### 3.1 技术选型
- **APScheduler**: Python定时任务框架
- **SQLAlchemy**: 数据库操作
- **PostgreSQL**: 持久化存储

### 3.2 调度器配置

```python
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from apscheduler.executors.pool import ThreadPoolExecutor

# 配置
jobstores = {
    'default': SQLAlchemyJobStore(url='postgresql://user:pass@localhost/taskmanager')
}

executors = {
    'default': ThreadPoolExecutor(10)
}

job_defaults = {
    'coalesce': True,  # 合并错过的执行
    'max_instances': 1,  # 同一任务最多同时运行1个实例
    'misfire_grace_time': 3600  # 错过执行的宽限时间(秒)
}

scheduler = BackgroundScheduler(
    jobstores=jobstores,
    executors=executors,
    job_defaults=job_defaults,
    timezone='Asia/Shanghai'
)
```

## 4. 业务逻辑层

### 4.1 SchedulerService类

```python
from datetime import datetime, timedelta
from app.models.task import Task
from app.utils.database import db_session
from app.services.notification_service import NotificationService
from app.services.task_service import TaskService
from sqlalchemy import and_

class SchedulerService:
    """定时任务业务逻辑服务"""

    @staticmethod
    def reset_periodic_tasks():
        """
        重置周期任务
        检查所有"定时周期任务"类型的任务，如果已完成或关闭，根据周期重置
        """
        print(f'[{datetime.now()}] 开始重置周期任务')

        # 查询所有定时周期任务
        periodic_tasks = db_session.query(Task).filter(
            Task.category == TaskService.CATEGORY_PERIODIC,
            Task.status.in_([TaskService.STATUS_COMPLETED, TaskService.STATUS_CLOSED])
        ).all()

        reset_count = 0
        for task in periodic_tasks:
            try:
                # 检查是否到达周期时间点
                if SchedulerService._should_reset_task(task):
                    # 重置任务状态
                    task.status = TaskService.STATUS_NEW
                    task.progress = 0
                    task.time_progress = 0
                    task.actual_start_time = None
                    task.actual_end_time = None

                    # 更新期望时间(如果有周期配置)
                    SchedulerService._update_task_schedule(task)

                    db_session.commit()

                    # 发送通知
                    NotificationService.send_notification(
                        user_id=task.current_handler_id,
                        notification_type='任务重置',
                        title='周期任务已重置',
                        content=f'任务「{task.title}」已重置，请及时处理',
                        task_id=task.id
                    )

                    reset_count += 1

            except Exception as e:
                print(f'重置任务失败 task_id={task.id}: {str(e)}')
                db_session.rollback()

        print(f'[{datetime.now()}] 周期任务重置完成，共重置 {reset_count} 个任务')

    @staticmethod
    def _should_reset_task(task):
        """
        判断任务是否需要重置
        这里简化处理：如果任务完成后超过1天，则重置
        实际可以根据任务的自定义周期配置(需要扩展数据库字段)
        """
        if not task.actual_end_time:
            return False

        # 简单示例：每周重置
        days_since_completion = (datetime.now() - task.actual_end_time).days
        return days_since_completion >= 7

    @staticmethod
    def _update_task_schedule(task):
        """
        更新任务的期望时间
        简单示例：期望开始时间为今天，期望完成时间为7天后
        """
        task.expected_start_time = datetime.now()
        task.expected_end_time = datetime.now() + timedelta(days=7)

    @staticmethod
    def check_task_warnings():
        """
        检查任务预警
        检查所有"处理中"状态的任务，如果时间进度超过阈值但处理进度不足，发送预警
        """
        print(f'[{datetime.now()}] 开始检查任务预警')

        # 查询处理中的任务
        processing_tasks = db_session.query(Task).filter(
            Task.status == TaskService.STATUS_PROCESSING,
            Task.expected_start_time.isnot(None),
            Task.expected_end_time.isnot(None)
        ).all()

        warning_count = 0
        for task in processing_tasks:
            try:
                # 更新时间进度
                time_progress = task.calculate_time_progress()
                task.time_progress = time_progress
                db_session.commit()

                # 检查预警条件
                warning_level = SchedulerService._check_warning_level(task)
                if warning_level:
                    # 检查是否已经发送过此级别的预警(避免重复发送)
                    if not SchedulerService._has_sent_warning(task.id, warning_level):
                        NotificationService.notify_task_warning(task, warning_level)
                        SchedulerService._mark_warning_sent(task.id, warning_level)
                        warning_count += 1

            except Exception as e:
                print(f'检查任务预警失败 task_id={task.id}: {str(e)}')
                db_session.rollback()

        print(f'[{datetime.now()}] 任务预警检查完成，发送 {warning_count} 个预警')

    @staticmethod
    def _check_warning_level(task):
        """
        检查预警级别
        :return: 20, 10, 5 或 None
        """
        time_progress = task.time_progress
        progress = task.progress

        # 时间进度95%，但处理进度<95%
        if time_progress >= 95 and progress < 95:
            return 5

        # 时间进度90%，但处理进度<90%
        if time_progress >= 90 and progress < 90:
            return 10

        # 时间进度80%，但处理进度<80%
        if time_progress >= 80 and progress < 80:
            return 20

        return None

    @staticmethod
    def _has_sent_warning(task_id, warning_level):
        """
        检查是否已发送过此级别预警
        可以使用Redis缓存或数据库记录
        """
        # 简单实现：使用Redis
        try:
            from app.utils.redis_client import redis_client
            key = f'warning_sent:{task_id}:{warning_level}'
            return redis_client.exists(key)
        except:
            return False

    @staticmethod
    def _mark_warning_sent(task_id, warning_level):
        """
        标记预警已发送
        """
        try:
            from app.utils.redis_client import redis_client
            key = f'warning_sent:{task_id}:{warning_level}'
            # 设置24小时过期
            redis_client.setex(key, 86400, '1')
        except:
            pass

    @staticmethod
    def update_all_time_progress():
        """
        更新所有处理中任务的时间进度
        """
        print(f'[{datetime.now()}] 开始更新时间进度')

        tasks = db_session.query(Task).filter(
            Task.status.in_([TaskService.STATUS_PROCESSING]),
            Task.expected_start_time.isnot(None),
            Task.expected_end_time.isnot(None)
        ).all()

        for task in tasks:
            try:
                task.time_progress = task.calculate_time_progress()
            except Exception as e:
                print(f'更新时间进度失败 task_id={task.id}: {str(e)}')

        db_session.commit()
        print(f'[{datetime.now()}] 时间进度更新完成，共更新 {len(tasks)} 个任务')

    @staticmethod
    def cleanup_old_data():
        """
        清理旧数据(可选)
        - 删除3个月前已关闭的任务
        - 删除6个月前的已读通知
        """
        print(f'[{datetime.now()}] 开始清理旧数据')

        # 删除3个月前已关闭的任务
        three_months_ago = datetime.now() - timedelta(days=90)
        deleted_tasks = db_session.query(Task).filter(
            Task.status == TaskService.STATUS_CLOSED,
            Task.updated_at < three_months_ago
        ).delete()

        db_session.commit()

        print(f'[{datetime.now()}] 旧数据清理完成，删除 {deleted_tasks} 个任务')
```

## 5. 调度配置

### 5.1 启动调度器

```python
from app.services.scheduler_service import SchedulerService
from app import scheduler

def init_scheduler():
    """初始化定时任务"""

    # 1. 周期任务重置 - 每天凌晨2点执行
    scheduler.add_job(
        func=SchedulerService.reset_periodic_tasks,
        trigger='cron',
        hour=2,
        minute=0,
        id='reset_periodic_tasks',
        replace_existing=True
    )

    # 2. 任务预警检测 - 每小时执行一次
    scheduler.add_job(
        func=SchedulerService.check_task_warnings,
        trigger='interval',
        hours=1,
        id='check_task_warnings',
        replace_existing=True
    )

    # 3. 更新时间进度 - 每30分钟执行一次
    scheduler.add_job(
        func=SchedulerService.update_all_time_progress,
        trigger='interval',
        minutes=30,
        id='update_time_progress',
        replace_existing=True
    )

    # 4. 清理旧数据 - 每周日凌晨3点执行
    scheduler.add_job(
        func=SchedulerService.cleanup_old_data,
        trigger='cron',
        day_of_week='sun',
        hour=3,
        minute=0,
        id='cleanup_old_data',
        replace_existing=True
    )

    # 启动调度器
    scheduler.start()
    print('定时任务调度器已启动')

def shutdown_scheduler():
    """关闭调度器"""
    scheduler.shutdown()
    print('定时任务调度器已关闭')
```

### 5.2 应用集成

```python
# app/__init__.py
from flask import Flask
from apscheduler.schedulers.background import BackgroundScheduler

scheduler = BackgroundScheduler()

def create_app():
    app = Flask(__name__)

    # ... 其他初始化

    # 初始化定时任务
    from app.services.scheduler_service import init_scheduler
    init_scheduler()

    return app
```

## 6. 任务调度时间表

| 任务名称 | 执行频率 | 执行时间 | 说明 |
|---------|---------|---------|------|
| reset_periodic_tasks | 每天 | 02:00 | 重置周期任务 |
| check_task_warnings | 每小时 | 整点 | 检查任务预警 |
| update_time_progress | 每30分钟 | - | 更新时间进度 |
| cleanup_old_data | 每周 | 周日03:00 | 清理旧数据 |

## 7. 监控与日志

### 7.1 任务执行日志

```python
import logging

logger = logging.getLogger('scheduler')

def log_job_execution(func):
    """装饰器：记录任务执行日志"""
    def wrapper(*args, **kwargs):
        start_time = datetime.now()
        logger.info(f'任务开始: {func.__name__}')

        try:
            result = func(*args, **kwargs)
            duration = (datetime.now() - start_time).total_seconds()
            logger.info(f'任务完成: {func.__name__}, 耗时: {duration}秒')
            return result
        except Exception as e:
            logger.error(f'任务失败: {func.__name__}, 错误: {str(e)}')
            raise

    return wrapper

# 使用装饰器
@log_job_execution
def reset_periodic_tasks():
    # ...
    pass
```

### 7.2 任务监控API

```python
from flask import Blueprint, jsonify
from app import scheduler

scheduler_bp = Blueprint('scheduler', __name__)

@scheduler_bp.route('/api/scheduler/jobs', methods=['GET'])
def get_jobs():
    """获取所有定时任务状态"""
    jobs = []
    for job in scheduler.get_jobs():
        jobs.append({
            'id': job.id,
            'name': job.name,
            'next_run_time': job.next_run_time.isoformat() if job.next_run_time else None,
            'trigger': str(job.trigger)
        })

    return jsonify({'code': 0, 'data': jobs})

@scheduler_bp.route('/api/scheduler/jobs/<job_id>/run', methods=['POST'])
def run_job_now(job_id):
    """手动触发任务执行"""
    try:
        job = scheduler.get_job(job_id)
        if job:
            job.modify(next_run_time=datetime.now())
            return jsonify({'code': 0, 'message': '任务已触发'})
        else:
            return jsonify({'code': 404, 'message': '任务不存在'}), 404
    except Exception as e:
        return jsonify({'code': 500, 'message': str(e)}), 500
```

## 8. 错误处理

### 8.1 任务失败重试

```python
from apscheduler.triggers.interval import IntervalTrigger

def resilient_job(func, max_retries=3):
    """带重试机制的任务"""
    def wrapper():
        for attempt in range(max_retries):
            try:
                return func()
            except Exception as e:
                if attempt == max_retries - 1:
                    logger.error(f'任务失败(已重试{max_retries}次): {func.__name__}, 错误: {str(e)}')
                    raise
                else:
                    logger.warning(f'任务失败，正在重试({attempt + 1}/{max_retries}): {func.__name__}')
                    time.sleep(5)  # 等待5秒后重试

    return wrapper
```

### 8.2 异常通知

```python
def notify_on_failure(func):
    """任务失败时发送通知给管理员"""
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            # 通知管理员
            from app.models.user import User
            admins = db_session.query(User).filter_by(is_admin=True).all()
            for admin in admins:
                NotificationService.send_notification(
                    user_id=admin.id,
                    notification_type='系统错误',
                    title='定时任务执行失败',
                    content=f'任务 {func.__name__} 执行失败: {str(e)}'
                )
            raise

    return wrapper
```

## 9. 性能优化

### 9.1 批量处理
```python
# 批量更新时间进度
def update_all_time_progress():
    tasks = db_session.query(Task).filter(...).all()

    for task in tasks:
        task.time_progress = task.calculate_time_progress()

    # 批量提交
    db_session.commit()
```

### 9.2 限制并发
```python
# 使用信号量限制并发数
from threading import Semaphore

semaphore = Semaphore(5)  # 最多5个并发

def process_task(task):
    with semaphore:
        # 处理任务
        pass
```

## 10. 测试

### 10.1 单元测试

```python
import unittest
from app.services.scheduler_service import SchedulerService

class TestSchedulerService(unittest.TestCase):

    def test_check_warning_level(self):
        """测试预警级别判断"""
        # 创建测试任务
        task = Task(
            time_progress=95,
            progress=60
        )

        level = SchedulerService._check_warning_level(task)
        self.assertEqual(level, 5)

    def test_should_reset_task(self):
        """测试周期任务重置判断"""
        task = Task(
            category='定时周期任务',
            status='已完成',
            actual_end_time=datetime.now() - timedelta(days=8)
        )

        should_reset = SchedulerService._should_reset_task(task)
        self.assertTrue(should_reset)
```

### 10.2 手动触发测试

```bash
# 手动触发周期任务重置
curl -X POST http://localhost:5000/api/scheduler/jobs/reset_periodic_tasks/run \
  -H "Authorization: Bearer <admin_token>"

# 查看任务状态
curl http://localhost:5000/api/scheduler/jobs \
  -H "Authorization: Bearer <admin_token>"
```
